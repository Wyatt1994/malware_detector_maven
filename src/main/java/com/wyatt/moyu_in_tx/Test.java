package com.wyatt.moyu_in_tx;

import java.util.*;

public class Test {
    public static void main(String[] args) {
        int[] order_arr = new int[]{1,3,5,7,8,14};
        int[] a = new int[]{1,4,3,5,2};
        int[] A = new int[]{1,3,3,5,7,7,7,7,8,14,14};
        System.out.println(binarySearch(order_arr, 14));
        System.out.println(binarySearchLowerInex(A, 14));
        System.out.println(Arrays.toString(bubbleSort(a)));
//        quickSort(a, 0 , a.length - 1);
//        mergeSort(a, 0, a.length - 1);
        heapSort(a);
        System.out.println(Arrays.toString(a));
    }


    //二分查找
    public static int binarySearch(int[] a, int target){
        int low = 0;
        int high = a.length-1, mid;
        while (low <= high){
            mid = low + (high - low)/2;
            if(a[mid] < target){
                low = mid + 1;
            }else if(a[mid] == target){
                return mid;
            }else {
                high = mid - 1;
            }
        }
        return -1;
    }

    //找到目标值的左边界
    public static int binarySearchLowerInex(int[] a , int target){
        int low = 0;
        int high = a.length - 1, mid;
        while (low <= high){
            mid = low + (high - low)/2;
            if(a[mid] >= target){
                high = mid - 1;
            }else {
                low = mid + 1;
            }
        }
        if(a[low] == target && low < a.length){
            return low;
        }else {
            return -1;
        }
    }

    //冒泡排序
    public static int[] bubbleSort(int[] a){
        a = Arrays.copyOf(a, a.length);
        boolean flag = false;
        for (int i = 0; i < a.length - 1 && !flag; i++) {
            flag = true;
            for (int j = 0; j < a.length - 1 - i; j++) {
                if(a[j] > a[j + 1]){
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                    flag = false;
                }
            }
        }
        return a;
    }

    //快速排序
    public static void quickSort(int[] a, int low, int high){
        if(low < high){
            int index = partition(a, low, high);
            quickSort(a, low, index - 1);
            quickSort(a, index +1 , high);
        }
    }

    public static int partition(int[] a, int low, int high){
        int flag = a[low];
        while (low < high){
            while (low < high && a[high] > flag) high--;
            a[low] = a[high];
            while (low < high && a[low] < flag) low++;
            a[high] = a[low];
        }
        a[low] = flag;
        return low;
    }


    //归并排序
    public static void mergeSort(int[] a, int low, int high){
        if(low >= high){
            return;
        }
        int mid = low + (high - low)/2;
        mergeSort(a, low, mid);
        mergeSort(a, mid + 1, high);
        merge(a, low, mid, high, new int[a.length]);
    }

    public static void merge(int[] a, int low , int mid, int high, int[] tmp){
        int i = low;
        int j = mid + 1;
        int t = 0;
        while (i <= mid && j <= high){
            if(a[i] < a[j]){
                tmp[t++] = a[i++];
            }else {
                tmp[t++] = a[j++];
            }
        }
        while (i <= mid){
            tmp[t++] = a[i++];
        }
        while (j <= high){
            tmp[t++] = a[j++];
        }
        t = 0;
        while (low <= high){
            a[low++] = tmp[t++];
        }
    }

    public static void heapSort(int[] a){
        for (int i = a.length/2; i >= 0; i--) {
            heapAdjust(a, i ,a.length-1);
        }
        for (int i = a.length - 1; i > 0; i--) {
            int tmp = a[0];
            a[0] = a[i];
            a[i] = tmp;

            heapAdjust(a, 0, i);
        }
    }

    public static void heapAdjust(int[] a, int parent, int maxIndex){
        int tmp = a[parent];
        int child = parent * 2 + 1;
        while (child < maxIndex){
            int maxChild = child;
            if(child + 1 < maxIndex){
                maxChild = a[child] > a[child + 1] ? child : child + 1;
            }
            if(tmp < a[maxChild]){
                a[parent] = a[maxChild];
                parent = maxChild;
                child = 2 * maxChild + 1;
            }else {
                break;
            }
        }
        a[parent] = tmp;
    }

    //先序遍历
    public static void preOrderTraverse(Node root){
        if(root == null){
            return;
        }
        Stack<> stack = new Stack();
        stack.push(root);
        while (!stack.isEmpty()){
            Node tmp = stack.pop();
            System.out.println(tmp);
            if(root.right != null){
                stack.push(root.right);
            }
            if(root.left != null){
                stack.push(root.left);
            }

        }
    }

    //中序遍历
    public static void inOrderTraverse(Node root){
        if (root == null){
            return;
        }
        Stack<> stack = new Stack();
        Node current = root;
        while (!stack.isEmpty() || current != null){
            while (current != null){
                stack.push(current);
                current = current.left;
            }
            if(!stack.isEmpty()){
                current = stack.pop();
                System.out.println(current);
                stack.push(current.right);
            }

        }
    }

    //后序遍历
    public static void postOrderTraverse(Node root, List list){
        if(root == null){
            return;
        }
        Stack<> stack = new Stack();
        stack.push(root);
        while (!stack.isEmpty()){
            Node tmp = stack.pop();
            list.add(tmp);
            if(tmp.left != null){
                list.add(tmp.left);
            }
            if(tmp.right != null){
                list.add(tmp.right);
            }

        }
        Collections.reverse(list);

    }

    public static void levleTraverse(Node root){
        if(root != null){
            return;
        }
        Queue<> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            Node tmp = queue.poll();
            System.out.println(tmp);
            if(tmp.left != null){
                queue.offer(tmp.left);
            }
            if(tmp.right != null){
                queue.offer(tmp.right);
            }
        }

    }
}
