package com.wyatt.Test_Singleton;

import org.junit.Test;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Created by ASUS on 2018/11/18.
 */
public class Test_singleton {


    @Test
    public void test_enum(){
        //测试枚举方式
        Singleton_enum one=Singleton_enum.INSTANCE;
        Singleton_enum two=Singleton_enum.INSTANCE;


        System.out.println(one==two);
    }

    @Test
    public void test_hungry(){
        //测试饿汉式
        Singleton_hungry one=Singleton_hungry.getSingleton();
        Singleton_hungry two=Singleton_hungry.getSingleton();

        System.out.println(one==two);
    }

    @Test
    public void test_innerclass(){
        //测试静态内部类
        Singleton_innerclass one=Singleton_innerclass.getSingleton();
        Singleton_innerclass two=Singleton_innerclass.getSingleton();

        System.out.println(one==two);

    }

    @Test
    public void test_lazy(){
        //测试懒汉式
        Singleton_lazy one=Singleton_lazy.getSingleton();
        Singleton_lazy two=Singleton_lazy.getSingleton();

        System.out.println(one==two);

    }

    @Test
    public void test_lazy_syn(){
        //测试synchronized修饰静态方法==等同于锁住类对象
        Singleton_lazy_syn one=Singleton_lazy_syn.getSingleton();
        Singleton_lazy_syn two=Singleton_lazy_syn.getSingleton();

        System.out.println(one==two);

    }

    @Test
    public void test_lazy_syn2(){
        //测试懒汉，使用synchronized锁类对象，并进行双重判空检查
        Singleton_lazy_syn2 one=Singleton_lazy_syn2.getSingleton();
        Singleton_lazy_syn2 two=Singleton_lazy_syn2.getSingleton();

        System.out.println(one==two);
    }



}
