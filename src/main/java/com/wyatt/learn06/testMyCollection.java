package com.wyatt.learn06;

import java.util.*;

/**
 * 自定义实现ArrayList
 * Created by wyatt on 2018/10/15.
 */
public class testMyCollection {

    public static void main(String[] args) {
        //测试ArrayList
        myArrayList<String> m1=new myArrayList();
        m1.add("aa");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        m1.add("bb");
        System.out.println(m1);
        System.out.println(m1.get(10));
        m1.set(10,"cc");
        System.out.println(m1);

        m1.remove(3);
        System.out.println(m1);

        System.out.println(m1.size());
        System.out.println(m1.isEmpty());


        //测试LinkedList
        MyLinkedList<String> list=new MyLinkedList();
        list.add("a");
        list.add("b");
        list.add("c");
        System.out.println(list);
        System.out.println(list.size());
        System.out.println(list.get(2));
        //删除节点
//        list.remove(2);
//        list.remove(0);
//        System.out.println(list);
        //index节点前插入
        //插入节点单独对尾节点操作
        list.add(3,"d");
        System.out.println(list);



        //测试HashMap
        Map map=new HashMap();
        map.put(1,"ss");
        map.put("ss",2);
        System.out.println(map.get(1));
        System.out.println(map.containsKey("ss"));
        Map map1=new HashMap();
        map1.put(1,"aa");
        map1.put("1","bb");
        map1.put("ss",2);
        //合并map,若重复，则以后加入的覆盖之前的
        map.putAll(map1);
        System.out.println(map);

        //测试MyHashMap
        MyHashMap m=new MyHashMap();
        //测试重复键值覆盖
//        m.put(10,"aa");
//        m.put(20,"bb");
//        m.put(10,"cc");
//        m.put("dd",30);


        //测试hash值碰撞
        m.put(1,'w');
        m.put(17,'y');
        m.put(33,'a');
        m.put(49,'t');
        m.put(65,'t');
        m.put(2,'g');
        System.out.println(m);

        //get方法获取值
        System.out.println(m.get(1));

        //remove方法移除
        m.remove(2);
        System.out.println(m);
        //因为int整数的hashcode就是自身的值，因此无需使用hashcode()方法
//        for (int i = 0; i < 20; i++) {
//            System.out.println(i+"--"+m.myHash(,16));
//        }


        //测试TreeMap
        Map<Integer,String> treemap=new TreeMap<>();
        treemap.put(20,"aa");
        treemap.put(3,"bb");
        treemap.put(10,"cc");
        //按照key自增排序
        for (Integer key:treemap.keySet()){
            System.out.println(key+"--"+treemap.get(key));
        }

        Map<Student,String> treemap1=new TreeMap<>();
        treemap1.put(new Student(100,"wy",2000),"me");
        treemap1.put(new Student(20,"wj",12000),"you");
        treemap1.put(new Student(60,"wc",200),"him");
        treemap1.put(new Student(30,"wc",200),"him");
        System.out.println(treemap1);

        List<Student> stuList=new ArrayList<>();
        stuList.add(new Student(100,"wy",2000));
        stuList.add(new Student(20,"wj",12000));
        stuList.add(new Student(60,"wc",200));
        stuList.add(new Student(30,"wc",200));
        //使用Comparator排序
        Collections.sort(stuList,new StuComparator());
        Iterator iter=stuList.iterator();
        while (iter.hasNext()){
            System.out.println(iter.next());
        }

    }
}

//Comparator实现Student排序

class StuComparator implements Comparator<Student>{
    @Override
    public int compare(Student s1, Student s2) {
        if (s1.number>s2.number){
            return 1;
        }else if (s1.number<s2.number){
            return -1;
        }else {
            if (s1.id>s2.id){
                return 1;
            }else if (s1.id<s2.id){
                return -1;
            }else {
                return 0;
            }
        }
    }
}
//用于treeMap自定义排序测试
class Student implements Comparable<Student>{
    int id;
    String name;
    long number;

    public Student(int id, String name, long number) {
        this.id = id;
        this.name = name;
        this.number = number;
    }

    @Override
    public int compareTo(Student s) {//负数：小于，0：等于，正数：大于
        //先比较number，若相等，再比较id，若依然相等，则返回0
        if(this.number>s.number){
            return 1;
        }else if (this.number<s.number){
            return -1;
        }else{
            if (this.id>s.id){
                return 1;
            }else if (this.id<s.id){
                return -1;
            }else {
                return 0;
            }
        }
    }

    @Override
    public String toString() {
        return "id"+id+"name"+name+"number"+number;
    }
}

class myArrayList<E>{
    //包含null元素的数组
    private Object[] elementData;

    //非空的元素个数
    private int size;
    private static final int DEFAULT_CAPACITY=10;

    public myArrayList(){
        elementData=new Object[DEFAULT_CAPACITY];

    }

    public myArrayList(int capacity){
        if (capacity<0){
            throw new RuntimeException("容量大小非法");
        }else if(capacity==0){
            //真实的ArrayList设置为0时并不是为默认长度10，而是0.当执行add操作时按照1.5倍增加
            elementData=new Object[DEFAULT_CAPACITY];
        }
        elementData=new Object[capacity];

    }

    public int size(){
        return size;
    }
    public boolean isEmpty(){
        return size==0?true:false;
    }

    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();

        //[a,b,c]
        sb.append("[");
        for (int i=0;i<size;i++) {
            sb.append(elementData[i]+",");
        }
        sb.setCharAt(sb.length()-1,']');
        return sb.toString();
    }

    public void add(E element){
        if (size==elementData.length){
            Object[] newArray=new Object[elementData.length+(elementData.length>>1)];
            System.arraycopy(elementData,0,newArray,0,elementData.length);
            elementData=newArray;
        }

        elementData[size++]=element;
    }

    public E get(int index){
        checkIndex(index);
        return (E)elementData[index];
    }
    public void set(int index,E element){
        checkIndex(index);
        elementData[index]=element;
    }

    public void remove(E element){
        //遍历挨个比较
        for (int i = 0; i < size; i++) {
            if (element.equals(get(i))){
                remove(i);
            }
        }
    }
    public void remove(int index){
        checkIndex(index);
        //也可以判断移动的个数是否为0，为0可以不用拷贝，直接删除
        //必须为elementData.length而不是size是保证数组长度包含扩展为null的元素
        System.arraycopy(elementData,index+1,elementData,index,elementData.length-index-1);
        elementData[--size]=null;


    }

    public void checkIndex(int index){
        if (index<0||index>size-1){
            throw new RuntimeException("索引不合法");
        }
    }

}

class MyLinkedList<E>{
    private Node first;
    private Node last;
    private int size;


    public int size(){
        return size;
    }
    public void add(E element){
        Node node=new Node(element);
        if (first==null){
            first=node;
            last=node;
            //初始化为双向链表，非必要，移除时还是首尾节点需要单独操作
//            first.pre=last;
//            last.next=first;
        }
        else {
            //默认在尾部插入
            node.pre=last;
            node.next=null;
            last.next=node;
            last=node;

        }
        size++;
    }

    //在index节点前插入
    public void add(int index,E element){
        //checkIndex(index);
        if (index>=0&&index<size){
            Node temp=getNode(index);
            Node newNode=new Node(element);
            //在头节点插入
            if (index==0){
                newNode.pre=null;
                newNode.next=temp;
                temp.pre=newNode;
                first=newNode;
            }
            else {
                Node up=temp.pre;
                up.next=newNode;
                newNode.pre=up;
                newNode.next=temp;
                temp.pre=newNode;
            }
        }
        if (index==size){
            //在尾节点插入
            Node temp=getNode(index-1);
            Node newNode=new Node(element);
            if (index==size){
                newNode.pre=temp;
                newNode.next=null;
                temp.next=newNode;
                last=newNode;
            }
        }


        size++;


    }
    public void checkIndex(int index){
        if (index<0||index>size-1){
            throw new RuntimeException("索引不合法");
        }
    }
    public Node getNode(int index){
        checkIndex(index);
        Node temp=first;
        if (index<(size>>1)){
            for (int i = 0; i < index; i++) {
                temp=temp.next;
            }
        }else {
            temp=last;
            for (int i = size-1; i >index; i--) {
                temp=temp.pre;
            }
        }
        return temp;
    }
    public E get(int index){
        Node temp=getNode(index);
        return (E)temp.element;

    }

    public void remove(int index){
        Node temp=getNode(index);
        Node up=temp.pre;
        Node down=temp.next;
        //首尾节点单独操作
        if (index==0){
            first=down;
        }
        if (index==size-1){
            last=up;
        }
        if (down!=null){
            down.pre=up;
        }
        if (up!=null){
            up.next=down;
        }
        size--;
    }

    //遍历链表的元素
    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();
        Node temp=first;
        while (temp!=null){
            sb.append(temp.element);
            temp=temp.next;
            if (temp!=null){
                sb.append("—>");
            }
        }
        return sb.toString();
    }
}
class Node<E>{
    Node pre;
    E element;
    Node next;

    public Node(E element){
        this.element=element;
    }
    public Node(Node pre,Node next,E element){
        this.pre=pre;
        this.next=next;
        this.element=element;
    }

}
class  HashNode<K,V>{
    int hash;
    K key;
    V value;
    HashNode next;
}
class MyHashMap<K,V>{
    HashNode<K,V>[] table;
    int size;       //存放键值对个数
    static final int DEFAULT_CAPACITY=16;
    public MyHashMap(){
        table=new HashNode[DEFAULT_CAPACITY];//默认长度
    }

    //返回hash值
    public static int myHash(int hashcode,int length){
        //return hashcode%(length-1);//除法运算，效率低
        return hashcode&(length-1);//位运算取余

    }

    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder("{");
        //遍历table[]数组
        for (int i = 0; i < table.length; i++) {
            sb.append("[");
            HashNode temp=table[i];
            //遍历链表
            while (temp!=null){
                sb.append("(");
                sb.append(temp.key+":"+temp.value);
                sb.append("),");
                temp=temp.next;
            }
            sb.append("]");
        }
        sb.append("}");
        return sb.toString();
    }

    public void put(K key, V value){
        //考虑数组扩容问题



        //定义一个新的节点对象
        HashNode newNode=new HashNode();
        newNode.hash=myHash(key.hashCode(),table.length);
        newNode.key=key;
        newNode.value=value;
        newNode.next=null;

        HashNode temp=table[newNode.hash];
        //保存最后一个节点
        HashNode iterLast=null;
        if (temp==null){
            table[newNode.hash]=newNode;
        }
        else {
            //不为空则遍历链表，相同替换，不同则加到末尾
            while (temp!=null){
                if (temp.key.equals(key)){
                    temp.value=value;
                    return;
                }
                iterLast=temp;
                temp=temp.next;
            }
            iterLast.next=newNode;

        }
        size++;

    }

    //根据key调用get获取键值对
    public V get(K key){
        int hash=myHash(key.hashCode(),table.length);
        //若未找到，直接返回null
        V value=null;
        if (table[hash]!=null){
            HashNode temp=table[hash];
            while (temp!=null){
                if (temp.key.equals(key)){
                    value=(V)temp.value;
                    break;
                }else {
                    temp=temp.next;
                }
            }
        }
        return value;

    }

    public void remove(K key) {
        int hash = myHash(key.hashCode(), table.length);
        if (table[hash] != null) {
            HashNode temp = table[hash];
            //上一个节点
            HashNode up = null;
            while (temp != null) {
                if (temp.key.equals(key)) {
                    //删除节点为头结点
                    if (temp==table[hash]) {
                        if (temp.next != null) {
                            table[hash] = temp.next;
                            System.out.println("删除有后继头结点成功");
                            size--;
                            return;
                        } else {
                            table[hash] = null;
                            System.out.println("删除无后继头结点成功");
                            size--;
                            return;
                        }
                    } else {
                        //删除节点为尾节点
                        if (temp.next == null) {
                            up.next = null;
                            System.out.println("删除尾节点成功");
                            size--;
                            return;
                        } else {
                            up.next = temp.next;
                            System.out.println("删除中间节点成功");
                            size--;
                            return;
                        }
                    }
                }
                up=temp;
                temp = temp.next;
            }
            System.out.println("没有该节点，删除失败");
        }

    }


}