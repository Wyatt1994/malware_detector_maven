package com.wyatt.ByteBuffer_Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;

/**
 * Created by ASUS on 2018/12/4.
 */
public class Test_ByteBuffer {
    public static void main(String[] args) throws Exception{
        FileChannel in=new FileInputStream("1.txt").getChannel(),out=new FileOutputStream("1.txt").getChannel();
        ByteBuffer buffer=ByteBuffer.allocate(64);
        buffer.put("wyatt is good!1".getBytes());
        //令limit=position,position=0，即buffer写模式切换为读模式
        buffer.flip();

        //读取buffer，写入输出流
        out.write(buffer);

        //令position=0,limit=capacity
        buffer.clear();
        //in，即channel本身也会维护一个positon，read之后其position值为buffer的有效长度
        in.read(buffer);
        //也可以用rewind(),即position=0,limit不会变化,即循环读取
        buffer.flip();
        //会把buffer全读出来
        //buffer.rewind();
        //必须为偶数字节，不然会溢出，BufferUnderflowException
        System.out.println(buffer.remaining());
        System.out.println(buffer.limit());
        System.out.println(in.position());
        while (buffer.remaining()>2){
            //mark=position
            buffer.mark();
            byte ch1=buffer.get();
            byte ch2=buffer.get();
            //positon=mark
            buffer.reset();
            //覆盖前两位的值
            buffer.put(ch2).put(ch1);
        }
        buffer.flip();
        System.out.println(in.position());
        //但容易出现中文乱码问题，需要设定编码
        CharBuffer cb= Charset.forName("utf-8").decode(buffer);
        System.out.println(cb);
//        while (buffer.hasRemaining()){
//            System.out.println((char)buffer.get());
//        }

        //建立一个通用缓冲器
        ByteBuffer bf = ByteBuffer.allocate(1024);

        //先进行存储一个字节
        bf.put((byte)'a');
        //存入一个char
        bf.putChar((char)'b');
        //存入一个double
        bf.putDouble(3.1415926D);
        //存入一个long
        bf.putLong(14L);
        //存入一个int
        bf.putInt(13);

        //先把数据整理好，用flip方法。
        bf.flip();
        //把缓冲器中的数据运入输出通道
        out.write(bf);

        //先清空缓冲器
        bf.clear();
        System.out.println(bf.limit());
        //in的position为15，因为
        System.out.println(in.position());

        //由于in本身维护了position值为15，故从16开始读
        in.read(bf);
        bf.flip();
        System.out.println(bf.remaining());
        //接下来我们对数据进行读取
        //读取一个字节
        System.out.println(bf.get());
        //读取一个char
        System.out.println(bf.getChar());
        //读取一个double
        System.out.println(bf.getDouble());
        //读取一个Long
        System.out.println(bf.getLong());
        //读取一个int
        System.out.println(bf.getInt());

        in.close();
        out.close();
    }
}
