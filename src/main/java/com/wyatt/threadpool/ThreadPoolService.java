package com.wyatt.threadpool;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;

/**
 * Created by ASUS on 2018/11/11.
 */
public class ThreadPoolService {

    //默认线程池大小
    private static int THREAD_COUNT=5;

    private TaskQueue queue=new TaskQueue();

    //线程池服务本身的状态，跟Task状态是独立的


    public enum Status{
        NEW,RUNNING,TERMINATED
    }

    private Status status=Status.NEW;

    private List<Thread> threads=new ArrayList<>();


    private void NewThread(){
        for (int i = 0; i < THREAD_COUNT; i++) {
            TaskThread t=new TaskThread(this);
            threads.add(t);
        }
    }
    public ThreadPoolService(){
        NewThread();
    }

    //设定线程池大小的构造方法
    public ThreadPoolService(int count){
        if (count>0){
            THREAD_COUNT=count;
            NewThread();
        }
        else {
            System.out.println("线程数量非法");
        }
    }

    public void execute(){
        this.status=Status.RUNNING;
        for (int i = 0; i < THREAD_COUNT; i++) {
            System.out.println("线程池数量为："+threads.size());
            threads.get(i).start();
        }
    }

    public void stop(){
        this.status=Status.TERMINATED;
    }

    // 是否正在运行,用于线程类中进行判断
    public boolean isRunning() {
        return status == Status.RUNNING;
    }

    //执行一个任务
    public void addTask(Task task){
        task.setState(Task.State.NEW);
        queue.addTask(task);
    }

    //用于让线程获取TaskQueue，因为是private
    TaskQueue getTaskQueue(){
        System.out.println("队列任务数为："+queue.getTaskCount());
        return this.queue;
    }


}
