package com.wyatt.produce_consumer;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by ASUS on 2018/11/20.
 */
public class ReentrantLock_Test<E> {

    private final static int MAX=3;

    private LinkedList<E> list=new LinkedList<>();
    private ReentrantLock lock=new ReentrantLock();
    private Condition notFull=lock.newCondition();
    private Condition notEmpty=lock.newCondition();

    public static void main(String[] args) {
        final ReentrantLock_Test container=new ReentrantLock_Test();
        for (int i = 0; i < 5; i++) {
            //生产者
            new Thread(new Runnable() {
                @Override
                public void run() {
                    String pro_name="producer_"+Thread.currentThread().getName();
                    System.out.println(pro_name+"生产了一个商品");
                    container.put("made by"+pro_name);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
            //消费者
            new Thread(new Runnable() {
                @Override
                public void run() {
                    String con_name="consumer_"+Thread.currentThread().getName();
                    System.out.println(con_name+"消费了一个商品"+container.get());

                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }

    public E get(){
        E e=null;
        lock.lock();
        try {
            while (list.size()==0){
                notEmpty.await();
            }

        e=list.removeFirst();
        notFull.signalAll();
        }catch (InterruptedException e1) {
            e1.printStackTrace();
        }finally {
            lock.unlock();
        }
        return e;
    }

    public void put(E e){

        lock.lock();
        try {
            while (list.size()==MAX) {
                notFull.await();
                }
            list.addLast(e);
            notEmpty.signalAll();
            }catch (InterruptedException e1) {
            e1.printStackTrace();
        }finally {
            lock.unlock();
        }
    }


}
