package com.wyatt.distributed_lock;


import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by ASUS on 2018/11/26.
 */
public class Main {
    public static void main(String[] args) {
        new Thread(new UserThread(),"user1").start();
        new Thread(new UserThread(),"user2").start();
        new Thread(new UserThread(),"user3").start();
        new Thread(new UserThread(),"user4").start();

    }
    //使用可重入锁进行锁定
    //static ReentrantLock lock=new ReentrantLock();
    //使用mysql行级锁
    //static SqlLock lock=new SqlLock();
    //使用redis进行加锁：利用redis的单线程串行的特点，使用setnx,根据其返回值判定是否有人占用，并设定过期时间避免死锁。
    //在释放锁时，可以通过使用lua脚本避免异常导致的未释放锁
    //static RedisLock lock=new RedisLock();
    //使用Zookeeper加锁：每一个线程在zookeeper上创建一个连续且有序的临时节点，选择节点值最小的获取锁。
    // 一旦关闭和zookeeper的连接，该节点会自动被删除，监听到该事件并自动选择下一个节点
    static ZookeeperLock lock=new ZookeeperLock();



    static class UserThread implements Runnable{
        @Override
        public void run() {
                new Order().createOrder();
                lock.lock();
                boolean result=new Stock().reduceStock();
                lock.unlock();
                if (result){
                    System.out.println("减库存成功");
                }
                else {
                    System.out.println("减库存失败");
                }

        }
    }
}
