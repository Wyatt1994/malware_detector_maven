package com.wyatt.dataStructure.tree;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class LinkedBinaryTree implements BinaryTree{

	private Node root;//根结点
	//private int size;
	
	public LinkedBinaryTree() {
		super();
	}

	public LinkedBinaryTree(Node root) {
		super();
		this.root = root;
	}

	@Override
	public boolean isEmpty() {		
		return root == null;
	}

	@Override
	public int size() {
		System.out.println("二叉树结点个数：");
		return this.size(root);
	}
	
	private int size(Node root) {
		if(root == null){
			return 0;
		}else{			
			//获取左子树的size
			int nl = this.size(root.leftChild);
			//获取右子树的size
			int nr = this.size(root.rightChild);			
			//返回左子树、右子树size之和并加1
			return nl+nr+1;
		}
	}

	@Override
	public int getHeight() {
		System.out.println("二叉树的高度是：");
		return this.getHeight(root);
	}
	
	private int getHeight(Node root){
		if(root == null){
			return 0;
		}else{			
			//获取左子树的高度
			int nl = this.getHeight(root.leftChild);
			//获取右子树的高度
			int nr = this.getHeight(root.rightChild);			
			//返回左子树、右子树较大高度并加1
			return nl > nr ? nl+1:nr+1;
		}
	}

	@Override
	public Node findKey(int value) {
		return this.findKey(value,root);
	}
	
	public Node findKey(Object value,Node node) {
		//确定退出递归条件

		//递归的流程：先判断当前节点是否符合（即设置结束条件），不符合则进入递归，寻找左右子树，在判断左右子树是否符合
		//本质上是递归就是利用程序执行是栈结构的特性

		//该节点为空则返回，即为递归的结束条件1：可能为整个树的根节点，也可能是递归中叶子结点的左孩子和右孩子
		if (node==null){
			return null;
		}
		//当前节点符合条件则返回
		else if (node!=null&&node.value==value){
			return node;
		}
		//不满足则继续查找左右子树
		else {//递归体：
			//查找左子树
			Node left_node=findKey(value,node.leftChild);
			//查找右子树
			Node right_node=findKey(value,node.rightChild);
			if (left_node!=null&&left_node.value==value){
				return left_node;
			}
			if (right_node!=null&&right_node.value==value){
				return right_node;
			}else {
				//未找到该节点
				return null;
			}


		}

		
	} 
	
	@Override
	public void preOrderTraverse() {		
		if(root != null){
			//1.输出根结点的值
			System.out.print(root.value+"  ");
			//2.对左子树进行先序遍历
			//构建一个二叉树，根是左子树的根
			BinaryTree  leftTree = new LinkedBinaryTree(root.leftChild);
			leftTree.preOrderTraverse();
			//对右子树进行先序遍历
			//3.构建一个二叉树，根是左子树的根
			BinaryTree  rightTree = new LinkedBinaryTree(root.rightChild);
			rightTree.preOrderTraverse();
		}		
	
	}

	@Override
	public void inOrderTraverse() {
		System.out.println("中序遍历");
		this.inOrderTraverse(root);
		System.out.println();
		
	}
	
	private void inOrderTraverse(Node root) {//node7
		if(root != null){
			//遍历左子树
			this.inOrderTraverse(root.leftChild);//null
			//输出根的值
			System.out.print(root.value+"  ");//7
			//遍历右子树
			this.inOrderTraverse(root.rightChild);//null
		}		
	}

	@Override
	public void postOrderTraverse() {
		System.out.println("后序遍历");
		this.postOrderTraverse(root);
		System.out.println();
		
	}

	@Override
	public void postOrderTraverse(Node node) {
		if(node != null){
			//遍历左子树
			this.postOrderTraverse(node.leftChild);
			//遍历右子树
			this.postOrderTraverse(node.rightChild);
			//输出根的值
			System.out.print(node.value+"  ");
		}
		
	}


	//中序非递归遍历
	@Override
	public void inOrderByStack() {
		System.out.println("中序非递归遍历:");
		// 创建栈

		//核心：整个栈始终保持只有最两种元素：即所有左节点和当前父（根）节点
		Deque<Node> stack = new LinkedList<Node>();
		Node current = root;
		//注意是||条件！！！若栈非空，则出栈一个，故能保证始终能找到最近一层根节点的右子树
		while (current != null || !stack.isEmpty()) {
			//该循环入栈所有左节点和经过的父（根）节点，即找到current节点的左节点和根节点
			while (current != null) {
				stack.push(current);
				current = current.leftChild;
			}
			//然后最下层的左节点出栈，并指向右节点
			if (!stack.isEmpty()) {
				current = stack.pop();
				System.out.print(current.value + "  ");
				current = current.rightChild;
			}
		}
		System.out.println();
		int[] a = new int[3];


	}

	//前序非递归遍历
	@Override
	public void preOrderByStack() {
		System.out.println("前序非递归遍历:");
		Deque<Node> stack=new LinkedList<>();
		Node current=root;
		while (current!=null||!stack.isEmpty()){
			while (current!=null){
				System.out.print(current.value+"  ");
				stack.push(current);
				current=current.leftChild;
			}
			if (!stack.isEmpty()){
				current=stack.pop();
				current=current.rightChild;
			}
		}
		System.out.println();
		
	}


	//后序非递归遍历
	@Override
	public void postOrderByStack() {
		System.out.println("后序非递归遍历:");
		Deque<Node> stack=new LinkedList<>();
		Node current=root;
		/* 用来记录最新出栈的节点，
         * 如果当前节点的右儿子与flag相同，说明当前节点右子树已完成遍历
         */
		Node flag=null;
		ArrayList<Object> ans = new ArrayList<>(20);
			while (current!=null){
				stack.push(current);
				current=current.leftChild;
			}
		//主要思想：首先遍历root根节点的所有左节点，并依次入栈。
		// 对出栈的元素，如果没有右儿子或者虽然有右儿子但右儿子已完成遍历，
		// 即可完成出栈；否则，再次入栈，并把右儿子入栈，遍历右儿子的所有左儿子。
			while (!stack.isEmpty()){
				current=stack.pop();
				if (current.rightChild==null||current.rightChild==flag){
					System.out.print(current.value+"  ");
					flag=current;
				}
				else {
					stack.push(current);
					current=current.rightChild;
					while (current!=null){
						stack.push(current);
						current=current.leftChild;
					}
				}
			}
		System.out.println();
	}

	@Override
	//非递归层次遍历
	public void levelOrderByStack() {
		System.out.println("按照层次遍历二叉树");
		if(root == null) return;
	    Queue<Node> queue = new LinkedList<Node>() ;
	    queue.add(root);
		//若队列非空，则一直循环
	    while(queue.size() != 0)
	    {
			//len本质上就是记录当前层次的节点个数
	        int len = queue.size();
	        for(int i=0;i <len; i++)
	        {
				//核心：一旦出队一个元素，则将其左右孩子入队，因此保证了层次的顺序
	        	Node temp = queue.poll();
	            System.out.print(temp.value+" ");
	            if(temp.leftChild != null)  queue.add(temp.leftChild);
	            if(temp.rightChild != null) queue.add(temp.rightChild);
	        }
	    }
	    
	    System.out.println();
		
	}

}
