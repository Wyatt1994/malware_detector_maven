package com.wyatt.dataStructure.sort;

import com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Created by ASUS on 2018/10/28.
 */
public class Sort {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(split("abccsss",2)));
        String s="aa";
        String s2="aa的11我爱";
        Character c1 = 's';
        Character c2 = 's';
        System.out.println(c1==c2);
        System.out.println(getChinese(s2));
        System.out.println(s==(new String("aa")));
        System.out.println(s==s2);
        Integer a1=128;
        Integer a2=128;
        System.out.println(a1==a2);
        System.exit(1);
        int[] a = {9,8,7,6,5,1,3,0,10,-1,99,-10};
        System.out.println(Arrays.toString(bubbleSortMin(a)));
        System.out.println(Arrays.toString(bubbleSortMax(a)));
        System.out.print("快速排序：");
        System.out.println(Arrays.toString(quickSort(a)));
        System.out.print("选择排序：");
        System.out.println(Arrays.toString(selectSort(a)));
        System.out.print("插入排序：");
        System.out.println(Arrays.toString(insertSort(a)));
        System.out.print("堆排序：");
        System.out.println(Arrays.toString(heapSort(a)));
        System.out.print("归并排序：");
        System.out.println(Arrays.toString(mergeSort(a)));
    }
    public static String getChinese(String s){
        int length = s.length();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            String tmp = String.valueOf(s.charAt(i));
            if(tmp.getBytes().length > 1){
                sb.append(tmp);
            }
        }
        return sb.toString();
    }
    public static String[] split(String str, int chars){
        int n = (str.length()+ chars - 1)/chars;
        String ret[] = new String[n];
        for(int i=0; i<n; i++){
            if(i < n-1){
                ret[i] = str.substring(i*chars , (i+1)*chars);
            }else{
                ret[i] = str.substring(i*chars);
            }}
        return ret;
    }


    /**
     * 冒泡排序算法：每次将最小的一个数”浮“上去
     * 最好情况O(n),即数组本身有序
     * 最坏情况O(n^2)
     */
    //每次上浮最大的数
    public static int[] bubbleSortMax(int[] a){
        a=Arrays.copyOf(a,a.length);
        int count=0;
        boolean flag=false;
        for (int i = 0; i < a.length - 1&&!flag; i++) {
            flag=true;
            for(int j=0;j<a.length-1-i;j++){
                count++;
                if (a[j]>a[j+1]){
                    flag=false;
                    int tmp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=tmp;
                }
            }
        }
        System.out.println("最大比较次数"+count);
        return a;
    }

    public static int[] bubbleSortMin(int[] a){
        a=Arrays.copyOf(a,a.length);
        int count=0;
        boolean flag=false;
        for (int i = 0; i < a.length - 1&&!flag; i++) {
            flag=true;
            for (int j=a.length-2;j>=i;j--){
                count++;
                if (a[j]>a[j+1]){
                    int tmp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=tmp;
                    flag=false;
                }
            }
        }
        System.out.println("最大比较次数"+count);
        return a;
    }


    //递归----快速排序
    public static int[] quickSort(int[] a){
        a=Arrays.copyOf(a,a.length);
        quickSort(a,0,a.length-1);
        return a;
    }

    public static void quickSort(int[] a,int low,int high){
        if (low>high){
            return;
        }
        int i=low;
        int j=high;
        int key=a[low];

        while (i!=j){
            //一个有=一个没有是因为key是从左边开始的，a[low]=key，应当跳过与key相等的值。而右边加不加=都可以
            while (j>i&&a[j]>key){
                j--;
            }
            while (i<j&&a[i]<=key){
                i++;
            }
            if (i<j){
                int tmp=a[i];
                a[i]=a[j];
                a[j]=tmp;
            }
        }
        //交换a[i]和a[low]的值
        int p=a[i];
        a[i]=a[low];
        a[low]=p;

        quickSort(a,low,i-1);
        quickSort(a,i+1,high);

    }



    //选择排序：每次选出排序中最小的一个
    //选择排序是对冒泡排序的改进，它的比较次数与冒泡排序相同，但交换次数要小于冒泡排序。
    //当数据量较大时，效率会有很大的提升，但时间复杂度仍为O(n*n)
    public static int[] selectSort(int[] a){
        a=Arrays.copyOf(a,a.length);
        int count=0;
        for (int i = 0; i < a.length - 1; i++) {
            int min=a[i];
            int minIndex=i;
            for (int j=i+1;j<a.length;j++){
                count++;
                if (min>a[j]){
                    minIndex=j;
                    min=a[j];
                }
            }
            int tmp=a[i];
            a[i]=min;
            a[minIndex]=tmp;

        }
        System.out.println("比较次数为"+count);
        return a;
    }


    //插入排序
    //从第二个元素开始，作为比较值跟他左边所有元素进行比较，比他大则将元素右移，直到找到比它小的或到达最左边，即插入
    public static int[] insertSort(int[] a){
        a=Arrays.copyOf(a,a.length);
        int count=0;
        for (int i = 1; i <a.length ; i++) {
            int tmp=a[i];
            int j=i-1;
            while (j>=0&&a[j]>tmp){
                count++;
                //若左边元素比它大，则右移。直到移到最左边或找到比它小的值
                a[j+1]=a[j];
                j--;
            }
            //当移到最左边（j=-1)或a[j]<=tmp,则把tmp值赋给a[j+1]
            a[j+1]=tmp;
        }
        System.out.println("比较次数为"+count);
        return a;
    }


    /**
     * 堆排序
     * @param a
     * @return
     */

    //该方法根据传入的parent和最大索引向下筛选创建最大堆
    public static void HeapAdjust(int[] a,int parent,int maxIndex){
        //tmp保存当前父节点
        int tmp=a[parent];
        //获得左孩子
        int child=2*parent+1;
        while (child<maxIndex){
            //若有右孩子，且右孩子大于左孩子，则选取右孩子和父节点比较
            if (child+1<maxIndex&&a[child]<a[child+1]){
                //若左孩子小于右孩子，则child+1即表示右孩子的索引
                child++;
            }
            //左右孩子中的更大值与父节点进行比较
            if (tmp>=a[child]){
                //父节点最大，直接结束
                break;
            }
            //否则将更大值赋给父节点
            a[parent]=a[child];


            //将选出的更大孩子节点作为父节点，继续向下筛选
            parent=child;
            child=2*child+1;


        }
        //将最初输入的父节点的值放入合适的位置
        a[parent]=tmp;

    }

    public static int[] heapSort(int[] a){


        //循环建立初始堆，从下往上构建，即从倒数第二层的最后一个父节点开始，
        //构建到倒数二层会向下筛选到最后一层，构建到倒数第三层时，也会向下筛选到最后一层
        a=Arrays.copyOf(a,a.length);
        ////2*i+1<=length-1,i初始值为最后一个有左孩子的节点索引
        for (int i=a.length/2;i>=0;i--){
            HeapAdjust(a,i,a.length-1);
        }


        //取出堆顶元素，与数组最后一个元素进行交换，然后再将剩余元素构造大顶堆，再将堆顶元素放到数组倒数第二的位置
        //进行n-1此循环，完成排序
        for (int i=a.length-1;i>0;i--){
            //最后一个元素和第一个元素进行交换
            int tmp=a[i];
            a[i]=a[0];
            a[0]=tmp;

            //筛选节点，得到i-1个节点的堆

            //此时是从上到下构建，headadjust函数是一直向下筛选的，即child=2*child+1递增
            HeapAdjust(a,0,i);
            System.out.format("第 %d 趟: \t", a.length - i);
            System.out.println();

        }
        return a;
    }


    //归并排序
    //https://blog.csdn.net/u010853261/article/details/54894057
    public static int[] mergeSort(int[] a){
        a=Arrays.copyOf(a,a.length);
        int[] tmp=new int[a.length];
        //mergeSort(a,0,a.length-1,tmp);
        //第二种归并排序，优化mid=(right-left)/2+left;
        sort(a,0,a.length-1,tmp);
        return a;
    }
    public static void  mergeSort(int[] a,int low,int high,int[] tmp){
        if (low<high){
            int mid=(low+high)/2;

            mergeSort(a,low,mid,tmp);
            mergeSort(a,mid+1,high,tmp);

            merge(a,low,mid,high,tmp);
        }
    }

    public static void merge(int[] a,int low,int mid,int high,int[] tmp){
        //设置两个数组的起始边界
        int i=low;
        int j=mid+1;
        //设置两个数组的结束边界
        int m=mid;
        int n=high;

        int k=0;

        while (i <= m && j<=n){
            if(a[i] <= a[j]){
                tmp[k++] = a[i++];
            }else {
                tmp[k++] = a[j++];
            }
        }

        while (i<=m){
            tmp[k++] = a[i++];
        }

        while (j <= n){
            tmp[k++] = a[j++];
        }

        for(i=0; i<k; i++){
            a[low+i] = tmp[i];
        }

    }



    //第二种归并排序，分而治之的思想
    public static void sort(int[] arr,int left,int right,int[] tmp){
        if (left<right){
            int mid=(right-left)/2+left;
            sort(arr,left,mid,tmp);
            sort(arr,mid+1,right,tmp);
            merge1(arr,left,mid,right,tmp);
        }
    }
    public static void merge1(int[] arr,int left,int mid,int right,int[] tmp){
        //左边有序数组的起始边界
        int i=left;
        //右边有序数组的起始边界
        int j=mid+1;
        //mid就是左边有序数组的最大值，right则为右边有序数组的最大值

        //定义tmp临时数组的起始指针，从0到length-1
        int t=0;
        while (i<=mid&&j<=right){
            if (arr[i]<arr[j]){
                tmp[t++]=arr[i++];
            }else {
                tmp[t++]=arr[j++];
            }
        }

        //合并完若左边更长，将左边剩余元素填充进temp中
        while (i<=mid){
            tmp[t++]=arr[i++];
        }
        //将右序列剩余元素填充进temp中
        while (j<=right){
            tmp[t++]=arr[j++];
        }
        t = 0;
        //将temp中的元素全部拷贝到原数组中
        while(left <= right){
            arr[left++] = tmp[t++];
        }

    }





}
