package com.wyatt.dataStructure.sort;

import com.wyatt.dataStructure.tree.Node;
import com.wyatt.produce_consumer.ReentrantLock_Test;

import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by ASUS on 2019/3/12.
 */
public class TestSort {
    public static void main(String[] args) {
        int[] a = new int[]{1,4,3,5,2};
//        quickSort(a);
//        mergeSort(a);
        heapSort(a);
        System.out.println(Arrays.toString(a));


        //二叉树遍历
        //创建一个二叉树
        Node node5 = new Node(5, null, null);
        Node node4 = new Node(4, null, node5);

        Node node3 = new Node(3, null, null);
        Node node7 = new Node(7, null, null);
        Node node6 = new Node(6, null, node7);

        Node node2 = new Node(2, node3, node6);

        Node node1 = new Node(1,node4,node2);

        //先序遍历（深度优先遍历）
        System.out.println(preOrderTraverse(node1));
        System.out.println(preOrderTraverseNotRecu(node1));

        //中序遍历
        System.out.println(inOrderTraverse(node1));
        System.out.println(inOrderTraverseNotRecu(node1));

        //后序遍历
        System.out.println(postOrderTraverse(node1));
        System.out.println(postOrderTraverseNotRecu(node1));
        System.out.println(postOrderTraverseNotRecu2(node1));

        //层次遍历（广度优先遍历）
        System.out.println(levelOrderTraverse(node1));





    }

    public static void quickSort(int[] a){
        quickSort(a, 0, a.length-1);
    }

    public static void quickSort(int[] a, int low,int high){
        if (low>=high){
            return;
        }
        int partition = partition(a, low, high);
        quickSort(a, low, partition-1);
        quickSort(a,partition+1,high);
    }

    public static int partition(int[] a, int low, int high){
        int flag = a[low];
        while (low<high){
            while (low<high&&a[high]>flag){high--;}
            a[low] = a[high];
            while (low<high&&a[low]<flag){low++;}
            a[high] = a[low];
        }
        a[low] = flag;
        return low;
    }


    public static void mergeSort(int[] a){
        int[] tmp = new int[a.length];
        mergeSort(a,0,a.length-1,tmp);
    }

    public static void mergeSort(int[] a, int low, int high,int[] tmp){
        if (low<high){
            int mid = (high-low)/2+low;
            mergeSort(a,low,mid,tmp);
            mergeSort(a,mid+1,high,tmp);
            merge(a,low,mid,high,tmp);
        }
    }

    public static void merge(int[] a,int low, int mid, int high,int[] tmp){
        int leftStart = low;
        int rightStart = mid+1;
        int t = 0;
        while (leftStart<=mid&&rightStart<=high){
            if (a[leftStart]<a[rightStart]){tmp[t++] = a[leftStart++];}
            else {tmp[t++] = a[rightStart++];}

        }
        while (leftStart<=mid){tmp[t++] = a[leftStart++];}
        while (rightStart<=high){tmp[t++] = a[rightStart++];}

        //将temp中的元素全部拷贝到原数组中
        t = 0;
        while(low <= high){
            a[low++] = tmp[t++];
        }
    }


    //从小到大，就是大顶堆
    //然后将堆顶，即最大值与最后一个值进行交换，即最大值到达正确位置
    //然后将n-1数组元素继续重复交换操作
    public static void heapSort(int[] a){
        for (int i = a.length/2; i >=0; i--) {
            heapAdjust(a,i,a.length-1);
        }

        for (int i = a.length-1; i > 0; i--) {
            //最后一个元素和第一个元素进行交换
            int tmp=a[i];
            a[i]=a[0];
            a[0]=tmp;
            //筛选节点，得到i-1个节点的堆

            //此时是从上到下构建，headadjust函数是一直向下筛选的，即child=2*child+1递增
            heapAdjust(a,0,i);
        }
    }


    //构造大顶堆
    public static void heapAdjust(int[] a, int parent, int maxIndex){
        int tmp = a[parent];
        int child = 2*parent+1;
        while (child<maxIndex){
            int maxChild = child;
            if(child+1<maxIndex){
                maxChild = a[child]>a[child+1]?child:child+1;
            }
            //必须是tmp比较，而不是用a[parent]。因为必须层层向下调整，而不能只交换
            if (tmp>=a[maxChild]){
                break;
            }else {
                a[parent] = a[maxChild];

            }

            //将选出的更大孩子节点作为父节点，继续向下筛选
            parent=maxChild;
            child=2*maxChild+1;

        }
        a[parent] = tmp;

    }


    //递归先序遍历
    public static ArrayList<Integer> preOrderTraverse(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }

        preOrderTraverse(root,list);
        return list;
    }

    public static void preOrderTraverse(Node root,ArrayList<Integer> list){
        if(root == null){
            return;
        }
        list.add((Integer)root.value);
        preOrderTraverse(root.leftChild,list);
        preOrderTraverse(root.rightChild,list);

    }

    //非递归先序遍历
    public static ArrayList<Integer> preOrderTraverseNotRecu(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        Stack<Node> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            Node tmp = stack.pop();
            list.add((Integer) tmp.value);
            if (tmp.rightChild != null){stack.push(tmp.rightChild);}
            if (tmp.leftChild != null){stack.push(tmp.leftChild);}
        }

        return list;
    }

    //递归中序遍历
    public static ArrayList<Integer> inOrderTraverse(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        inOrderTraverse(root,list);
        return list;
    }

    public static void inOrderTraverse(Node root, ArrayList<Integer> list){
        if (root == null){
            return;
        }

        inOrderTraverse(root.leftChild,list);
        list.add((Integer) root.value);
        inOrderTraverse(root.rightChild,list);
    }

    //非递归中序遍历
    public static ArrayList<Integer> inOrderTraverseNotRecu(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        Stack<Node> stack = new Stack<>();
        Node current = root;

        //注意是或条件，因为将左，根节点出栈完毕后，栈会为空，此时需要遍历其右节点
        while (!stack.isEmpty()||current!=null){
            while (current != null){
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.isEmpty()){
                current = stack.pop();
                list.add((Integer) current.value);
                current = current.rightChild;
            }
        }
        return list;
    }


    //递归后序遍历
    public static ArrayList<Integer> postOrderTraverse(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        postOrderTraverse(root,list);
        return list;
    }

    public static void postOrderTraverse(Node root,ArrayList<Integer> list){
        if (root == null){
            return;
        }

        postOrderTraverse(root.leftChild,list);
        postOrderTraverse(root.rightChild,list);
        list.add((Integer) root.value);
    }

    //后序遍历非递归
    public static ArrayList<Integer> postOrderTraverseNotRecu(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        Stack<Node> stack = new Stack<>();
        Node current = root;
        Node flag = null;
        //主要思想：首先遍历root根节点的所有左节点，并依次入栈。
        // 对出栈的元素，如果没有右儿子或者虽然有右儿子但右儿子已完成遍历，
        // 即可完成出栈；否则，再次入栈，并把右儿子入栈，遍历右儿子的所有左儿子。
        while (current!=null){
            stack.push(current);
            current = current.leftChild;
        }

        while (!stack.isEmpty()){
            current = stack.pop();
            if (current.rightChild == null||current.rightChild==flag){
                list.add((Integer)current.value);
                flag = current;
            }else {
                stack.push(current);
                current = current.rightChild;
                while (current!=null){
                    stack.push(current);
                    current = current.leftChild;
                }
            }
        }


        return list;
    }


    //后序遍历非递归2 ：前序遍历反转
    public static ArrayList<Integer> postOrderTraverseNotRecu2(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        Stack<Node> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            //反转过来 即根左右-》右左根，因此还需调换下左右孩子的入栈顺序
            Node tmp = stack.pop();
            list.add((Integer) tmp.value);
            if (tmp.leftChild != null){stack.push(tmp.leftChild);}
            if (tmp.rightChild != null){stack.push(tmp.rightChild);}
        }

        Collections.reverse(list);
        return list;
    }



    public static ArrayList<Integer> levelOrderTraverse(Node root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            Node tmp = queue.poll();
            list.add((Integer)tmp.value);
            if (tmp.leftChild != null){
                queue.offer(tmp.leftChild);
            }
            if (tmp.rightChild != null){
                queue.offer(tmp.rightChild);
            }
        }
        return list;

    }


        //链表首尾交替输出
//    public static Node convert(Node head){
//        Node fast = root;
//        Node slow = root;
//        while (fast!=null&&fast.next!=null){
//            slow = slow.next;
//            fast = fast.next.next;
//        }
//        //中间节点
//        Node mid = slow.next;
//        //断开前半边和后半边，用于交叉合并时循环判断退出条件
//        slow.next = null;
//        //反转后半边链表
//        Node reverseHead = reverse(mid);
//
//        Node cur1 = head;
//        Node cur2 = reverseHead;
//        while (cur1 !=null && cur2 !=null){
//            Node next1 = cur1.next;
//            Node next2 = cur2.next;
//            cur1.next = cur2;
//            cur2.next = next1;
//            cur1 = next1;
//            cur2 = next2;
//        }
//
//
//    }
//
//    public static Node reverse(Node head){
//        Node pre = null;
//        Node cur = head;
//        while (cur != null){
//            Node next = cur.next;
//            cur.next = pre;
//            pre = cur;
//            cur = next;
//        }
//        return cur;
//
//    }













}
