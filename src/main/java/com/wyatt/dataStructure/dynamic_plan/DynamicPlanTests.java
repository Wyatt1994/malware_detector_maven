package com.wyatt.dataStructure.dynamic_plan;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;

public class DynamicPlanTests {
    public static void main(String[] args) {

        int[] arr = {2,1,4,3,1,5,6};
        int[] arr2 = {1,2,3,4,1,5,6};
        int[] coins = {5,10,25,1};
        System.out.println(getLongestCommonArr(arr, arr2));
        System.out.println(getLongestDiZengArr(arr));
        //获得凑硬币方法数
        System.out.println(getCoinTotalWays(coins,3));
        //获得最少硬币数
        System.out.println(getMinCoinsCount(coins, 3));
        //01背包，获得最大价值
        System.out.println(getBagFor01(70, 3, new int[]{71,69,1},new int[]{100,1,2}));
        //完全背包，获得最大价值
        System.out.println(getBagForInfinite(70, 3, new int[]{71,69,1},new int[]{100,1,2}));
        //多重背包，获得最大价值
        System.out.println(getBagForDuoChong(1000, 5, new int[]{80,40,30,40,20}, new int[]{20,50,50,30,20}, new int[]{4,9,7,6,1}));
    }

    /**
     * 获取最长回文子串的长度
     *
     * 给定字符串A以及它的长度n，请返回最长回文子串的长度。
     * "abc1234321ab",12
     *
     * 返回：7
     * @return
     *
     * 1.dp[i][j]表示，若i到j已经是回文串了，那么dp[i][j]是回文串的长度，否则为0；
     * 2.初始时dp[i][i]=1，i=0,2,3...n-1；
     * 3.递归公式，len>2时，当dp[i+1][j-1]!=0,且a[i]==a[j]时，dp[i][j] = j-i+1+dp[i+1][j-1],  否则dp[i][j]=0，i<j。这是一个从已知回文串往两边展开的过程。
     *
     * 当len=2时，特殊处理一下，因为当len=2时，dp[i+1][j-1]会访问到dp矩阵的左下方，我们没对那个位置做初始化处理，因此不能直接用递推公式
     */
    public static int getLongestPalidrome(String A,int n){
        int[][] dp = new int[n][n];
        int max = 1;
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        char[] a = A.toCharArray();
        //步长，回文长度从最小2依次递增
        for(int len = 2; len <= n; len++){
            for(int i = 0; i <= n-len; i++){
                //步长，递增长度从1,2...到n-1
                int j = i+len-1;
                //len=2时单独处理，因为此时此时长度为2，上一个状态dp[i+1][j-1]无效。长度至少为3才能应用递推公式
                if(len == 2 && a[i] == a[j]){
                    dp[i][j] = len;
                    max = 2;
                    continue;
                }
                if(a[i] == a[j] && dp[i+1][j-1] != 0){
                    dp[i][j] = len;//也可以等于j-i+1+dp[i+1][j-1]
                    max = len;
                }
            }
        }
        return max;
    }


    /**
     * 最长公共子序列长度LCS，注：不要求连续！！！！！！！！
     * dp[i][j]表示arr1{a1,..ai}和arr2{a1,...aj}的LCS
     */

    public static int getLongestCommonArr(int[] arr1, int[] arr2){
        int maxLen = Math.max(arr1.length, arr2.length);
        int[][] dp = new int[maxLen][maxLen];
        //边界赋值
        for (int i = 0; i < maxLen; i++) {
            dp[i][0] = 0;
            dp[0][i] = 0;
        }
        for (int i = 1; i < arr1.length; i++) {
            for (int j = 1; j < arr2.length; j++) {
                if(arr1[i] == arr2[j]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[arr1.length-1][arr2.length-1];

    }

    /**
     * 最长递增子序列长度LIS, 注：不要求连续！！！！！！！！
     *
     * 对于一个数字序列，请设计一个复杂度为O(nlogn)的算法，返回该序列的最长递增子序列的长度，
     *
     * 给定一个数字序列A及序列的长度n，请返回最长递增子序列的长度。
     *
     * 测试样例：
     *
     * [2,1,4,3,1,5,6],7
     *
     * 1)先对原序列排序，再求两个序列的LCS（最长公共子序列长度）
     * 2）动态规划：dp[i]表示以序列中第i个元素结尾的最长递增子序列长度
     * 状态转移方程为：if (a[i] > a[j]) dp[i] = MAX (dp[i], dp[j] + 1);
     *
     */

    public static int getLongestDiZengArr(int[] arr){
        int max = 0;
        int[] dp = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            dp[i] = 1;
            //因为不要求递增连续，因此需要从0开始遍历寻找最大值
            for (int j = 0; j < i; j++) {
                if(arr[i] > arr[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            if(dp[i] > max){
                max = dp[i];
            }
        }
        return max;
    }


    /**
     * 换硬币方法数
     *
     * 面值为{5,10,25,1},求凑出面值为50的方法数
     *
     * dp[i][j]表示只用前i种硬币凑齐面值j的方法数
     *
     *
     */
    public static int getCoinTotalWays(int[] arr,int aim){
        if(arr == null || arr.length == 0 || aim<0){
            return 0;
        }

        int[][] dp = new int[arr.length][aim+1];

        /**
         * dp[][0]组成钱数为0的方法数，很明显都是1种，也就是
         * 不使用任何货币
         */
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;

        }
        /**
         * dp[0][],只使用第一种货币的话，第一种货币的整数倍是1
         * 其他的为0
         */

        for (int i = 1; arr[0]*i <=aim ; i++) {
            dp[0][arr[0]*i] = 1;

        }

        int num = 0;
        for (int i = 1; i < arr.length ; i++) {
            for (int j = 1; j <=aim ; j++) {
                num = 0;
                /**
                 * 完全不用arr[i]货币，方法数为arr[i-1][j]
                 * 用一张arr[i],剩下的由arr[0...i-1]组成
                 *方法数为dp[i-1][j-n*arr[i]]
                 */
                for (int k = 0; k*arr[i] <= j ; k++) {
                    num += dp[i-1][j-arr[i]*k];

                }
                dp[i][j] = num;

            }

        }
        return dp[arr.length-1][aim];



    }


    /**
     * 凑最少硬币数
     */
    public static int getMinCoinsCount(int[] arr, int aim){
        int[] dp = new int[aim+1];
        //初始化一个较大值
        for (int i = 1; i <= aim; i++) {
            dp[i] = 99999;
        }

        //从凑1元开始遍历，直到为aim面值
        for (int i = 1; i <= aim; i++) {
            for (int j = 0; j < arr.length; j++) {
                if(i >= arr[j]){
                    dp[i] = Math.min(dp[i-arr[j]]+1,dp[i]);
                }
            }
        }

        if(dp[aim] == 99999){
            return 0;
        }else {
            return dp[aim];
        }
    }


    /**
     * 0 1背包问题
     * 输出最大价值
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 70 3
     *
     * weight value
     * 71 100
     *
     * 69 1
     *
     * 1 2
     *
     * 样例输出 Sample Output
     * 3
     *
     */

    public static int getBagFor01(int capcity, int n, int[] weight, int[] value){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            //遍历j时从右到左，因为d[j]只依赖于上一阶段的结果

            //意思是从第0个物品开始，分为放和不放两种情况 。注意下界是weight[0]，避免越界
            for (int j = capcity; j >= weight[i]; j--) {
                //取选择第i个物品和不选择第i个物品的较大值
                dp[j] = Math.max(dp[j-weight[i]]+value[i],dp[j]);
            }
        }
        return dp[capcity];


    }

    /**
     * 完全背包问题：即数量不限
     *
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 70 3
     *
     * weight value
     * 71 100
     *
     * 69 1
     *
     * 1 2
     *
     * 样例输出 Sample Output
     * 140
     */

    public static int getBagForInfinite(int capcity, int n, int[] weight, int[] value){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            //注意与01背包的区别，遍历时从左到右，起始点为weight[0]

            //意思是同一种物体一直放，直到放满背包为止
            for (int j = weight[i]; j <= capcity; j++) {
                dp[j] = Math.max(dp[j-weight[i]]+value[i],dp[j]);
            }
        }

        return dp[capcity];
    }

    /**
     * 多重背包问题：即数量有限
     *
     * 状态转移方程：f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i]|0<=k<=n[i])
     *
     *
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 1000 5
     *
     * weight value num
     * 80 20 4
     *
     * 40 50 9
     *
     * 30 50 7
     *
     * 40 30 6
     *
     * 20 20 1
     * 样例输出 Sample Output
     * 1040
     */

    public static int getBagForDuoChong(int capcity, int n, int[] weight, int[] value, int[] num){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            for (int j = capcity; j >= 0 ; j--) {
                //限制条件1：不能超过物品数量
                for (int k = 0; k <= num[i]; k++) {
                    //限制条件2: 不能超过当前背包容量
                    if(j-k*weight[i] >= 0){
                        dp[j] = Math.max(dp[j-k*weight[i]]+k*value[i],dp[j]);
                    }else {
                        break;
                    }
                }
            }
        }

        return dp[capcity];
    }





}
