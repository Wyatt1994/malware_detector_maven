package com.wyatt.dataStructure.dynamic_plan;

import com.sun.jmx.remote.internal.ArrayQueue;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.*;

public class DynamicPlanTests {
    public static void main(String[] args) {

        String str = "aaa";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        try {
            System.out.println(sdf.parse("2019-09-10 10:00:01"));

        }catch (Exception e){
            e.printStackTrace();
        }
        int[] arr = {2,1,4,3,1,5,6};
        int[] arr2 = {1,2,3,4,1,5,6};
        int[] coins = {5,10,25,1};
        find(coins, 0, 2, new ArrayList<>());
        System.out.println(Arrays.toString(res.toArray()));
        System.exit(0);
        System.out.println(getLongestCommonArr(arr, arr2));
        System.out.println(getLongestDiZengArr(arr));
        //获得凑硬币方法数
        System.out.println(getCoinTotalWays(coins,3));
        //获得最少硬币数
        System.out.println(getMinCoinsCount(coins, 3));
        //01背包，获得最大价值
        System.out.println(getBagFor01(70, 3, new int[]{71,69,1},new int[]{100,1,2}));
        //完全背包，获得最大价值
        System.out.println(getBagForInfinite(70, 3, new int[]{71,69,1},new int[]{100,1,2}));
        //多重背包，获得最大价值
        System.out.println(getBagForDuoChong(1000, 5, new int[]{80,40,30,40,20}, new int[]{20,50,50,30,20}, new int[]{4,9,7,6,1}));
        find(coins, 0, 2, new ArrayList<>());
        System.out.println(res);
    }

    /**
     * 获取最长回文子串的长度
     *
     * 给定字符串A以及它的长度n，请返回最长回文子串的长度。
     * "abc1234321ab",12
     *
     * 返回：7
     * @return
     *
     * 1.dp[i][j]表示，若i到j已经是回文串了，那么dp[i][j]是回文串的长度，否则为0；
     * 2.初始时dp[i][i]=1，i=0,2,3...n-1；
     * 3.递归公式，len>2时，当dp[i+1][j-1]!=0,且a[i]==a[j]时，dp[i][j] = j-i+1+dp[i+1][j-1],  否则dp[i][j]=0，i<j。这是一个从已知回文串往两边展开的过程。
     *
     * 当len=2时，特殊处理一下，因为当len=2时，dp[i+1][j-1]会访问到dp矩阵的左下方，我们没对那个位置做初始化处理，因此不能直接用递推公式
     */
    public static int getLongestPalidrome(String A,int n){
        int[][] dp = new int[n][n];
        int max = 1;
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        char[] a = A.toCharArray();
        //步长，回文长度从最小2依次递增
        for(int len = 2; len <= n; len++){
            for(int i = 0; i <= n-len; i++){
                //步长，递增长度从1,2...到n-1
                int j = i+len-1;
                //len=2时单独处理，因为此时此时长度为2，上一个状态dp[i+1][j-1]无效。长度至少为3才能应用递推公式
                if(len == 2 && a[i] == a[j]){
                    dp[i][j] = len;
                    max = 2;
                    continue;
                }
                if(a[i] == a[j] && dp[i+1][j-1] != 0){
                    dp[i][j] = len;//也可以等于j-i+1+dp[i+1][j-1]
                    max = len;
                }
            }
        }
        return max;
    }


    /**
     * 最长公共子序列长度LCS，注：不要求连续！！！！！！！！
     * dp[i][j]表示arr1{a1,..ai}和arr2{a1,...aj}的LCS
     *
     * 如果求最长公共子串，则else条件设置为0即可
     */

    public static int getLongestCommonArr(int[] arr1, int[] arr2){
        int maxLen = Math.max(arr1.length, arr2.length);
        int[][] dp = new int[maxLen+1][maxLen+1];
        //边界赋值
        for (int i = 0; i < maxLen; i++) {
            dp[i][0] = 0;
            dp[0][i] = 0;
        }
        Stack<Integer> stack = new Stack<>();
        for (int i = 1; i <= arr1.length; i++) {
            for (int j = 1; j <= arr2.length; j++) {
                if(arr1[i-1] == arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[arr1.length-1][arr2.length-1];

    }

    /**
     * 最长递增子序列长度LIS, 注：不要求连续！！！！！！！！
     *
     * 对于一个数字序列，请设计一个复杂度为O(nlogn)的算法，返回该序列的最长递增子序列的长度，
     *
     * 给定一个数字序列A及序列的长度n，请返回最长递增子序列的长度。
     *
     * 测试样例：
     *
     * [2,1,4,3,1,5,6],7
     *
     * 1)先对原序列排序，再求两个序列的LCS（最长公共子序列长度）
     * 2）动态规划：dp[i]表示以序列中第i个元素结尾的最长递增子序列长度
     * 状态转移方程为：if (a[i] > a[j]) dp[i] = MAX (dp[i], dp[j] + 1);
     *
     */

    public static int getLongestDiZengArr(int[] arr){
        int max = 0;
        int[] dp = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            dp[i] = 1;
            //因为不要求递增连续，因此需要从0开始遍历寻找最大值
            for (int j = 0; j < i; j++) {
                if(arr[i] > arr[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            if(dp[i] > max){
                max = dp[i];
            }
        }
        return max;
    }


    /**
     * 换硬币方法数
     *
     * 面值为{5,10,25,1},求凑出面值为50的方法数
     *
     * dp[i][j]表示只用前i种硬币凑齐面值j的方法数
     *
     *
     */
    public static int getCoinTotalWays(int[] arr,int aim){
        if(arr == null || arr.length == 0 || aim<0){
            return 0;
        }

        int[][] dp = new int[arr.length][aim+1];

        /**
         * dp[][0]组成钱数为0的方法数，很明显都是1种，也就是
         * 不使用任何货币
         */
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;

        }
        /**
         * dp[0][],只使用第一种货币的话，第一种货币的整数倍是1
         * 其他的为0
         */

        for (int i = 1; arr[0]*i <=aim ; i++) {
            dp[0][arr[0]*i] = 1;

        }

        int num = 0;
        for (int i = 1; i < arr.length ; i++) {
            for (int j = 1; j <=aim ; j++) {
                num = 0;
                /**
                 * 完全不用arr[i]货币，方法数为arr[i-1][j]
                 * 用一张arr[i],剩下的由arr[0...i-1]组成
                 *方法数为dp[i-1][j-n*arr[i]]
                 */
                for (int k = 0; k*arr[i] <= j ; k++) {
                    num += dp[i-1][j-arr[i]*k];

                }
                dp[i][j] = num;

            }

        }
        return dp[arr.length-1][aim];



    }


    /**
     * 凑最少硬币数
     */
    public static int getMinCoinsCount(int[] arr, int aim){
        int[] dp = new int[aim+1];
        //初始化一个较大值
        for (int i = 1; i <= aim; i++) {
            dp[i] = 99999;
        }

        //从凑1元开始遍历，直到为aim面值
        for (int i = 1; i <= aim; i++) {
            for (int j = 0; j < arr.length; j++) {
                if(i >= arr[j]){
                    dp[i] = Math.min(dp[i-arr[j]]+1,dp[i]);
                }
            }
        }

        if(dp[aim] == 99999){
            return 0;
        }else {
            return dp[aim];
        }
    }

    /**
     * 凑硬币面值为s的方式数
     */

    public static int findSWays(int[] arr, int s){
        int[][] dp = new int[arr.length+1][s+1];
        for (int i = 0; i <= arr.length; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= arr.length; i++) {
            for (int j = 1; j <= s; j++) {
                dp[i][j] = 0;
                for (int k = 0; k <= j/arr[i-1]; k++) {
                    dp[i][j] += dp[i-1][j-k*arr[i-1]];
                }

            }

        }
        return dp[arr.length][s];
    }

    /**
     * 0 1背包问题
     * 输出最大价值
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 70 3
     *
     * weight value
     * 71 100
     *
     * 69 1
     *
     * 1 2
     *
     * 样例输出 Sample Output
     * 3
     *
     */

    public static int getBagFor01(int capcity, int n, int[] weight, int[] value){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            //遍历j时从右到左，因为d[j]只依赖于上一阶段的结果

            //意思是从第0个物品开始，分为放和不放两种情况 。注意下界是weight[0]，避免越界
            for (int j = capcity; j >= weight[i]; j--) {
                //取选择第i个物品和不选择第i个物品的较大值
                dp[j] = Math.max(dp[j-weight[i]]+value[i],dp[j]);
            }
        }
        return dp[capcity];


    }

    /**
     * 完全背包问题：即数量不限
     *
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 70 3
     *
     * weight value
     * 71 100
     *
     * 69 1
     *
     * 1 2
     *
     * 样例输出 Sample Output
     * 140
     */

    public static int getBagForInfinite(int capcity, int n, int[] weight, int[] value){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            //注意与01背包的区别，遍历时从左到右，起始点为weight[0]

            //意思是同一种物体一直放，直到放满背包为止
            for (int j = weight[i]; j <= capcity; j++) {
                dp[j] = Math.max(dp[j-weight[i]]+value[i],dp[j]);
            }
        }

        return dp[capcity];
    }

    /**
     * 多重背包问题：即数量有限
     *
     * 状态转移方程：f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i]|0<=k<=n[i])
     *
     *
     * 样例输入 Sample Input
     *
     * 背包容量 物品种类数
     * 1000 5
     *
     * weight value num
     * 80 20 4
     *
     * 40 50 9
     *
     * 30 50 7
     *
     * 40 30 6
     *
     * 20 20 1
     * 样例输出 Sample Output
     * 1040
     */

    public static int getBagForDuoChong(int capcity, int n, int[] weight, int[] value, int[] num){
        int[] dp = new int[capcity+1];
        for (int i = 0; i < n; i++) {
            for (int j = capcity; j >= 0 ; j--) {
                //限制条件1：不能超过物品数量
                for (int k = 0; k <= num[i]; k++) {
                    //限制条件2: 不能超过当前背包容量
                    if(j-k*weight[i] >= 0){
                        dp[j] = Math.max(dp[j-k*weight[i]]+k*value[i],dp[j]);
                    }else {
                        break;
                    }
                }
            }
        }

        return dp[capcity];
    }


    /**
     * n个糖果分给k个小朋友的方法数和所有分配方式
     * 输出方式为  方法数+*和|组合，例如 **|******|*，表示一次分配2、6和1个糖果
     * s：表示一种分配方式
     */
    List<Stack<String>> ans = new ArrayList<>();
    void dfs(int n, int k, Stack<String> s){
        if(n < 0||k < 0){
            return;
        }
        if(k == 0){
            for (int i = 0; i < n; i++) {
                s.push("*");
            }
            ans.add(s);
            for (int i = 0; i < n; i++) {
                s.pop();
            }
            return;
        }
        //先分配一个糖果
        s.push("*");
        //继续寻找n-1个糖果的分配方式
        dfs(n-1, k, s);
        //重置s,寻找下一种分配方式
        s.pop();

        //循环条件保证至少每个朋友分配一个，注释掉即为不限制为0
        if(!s.isEmpty()&&s.peek()!="|"){
            s.push("|");
            dfs(n, k-1, s);
            s.pop();
        }

    }


    //arr = {5,10,25,1};
    private static List<List<Integer>> res = new ArrayList<>();
    public static void find(int[] arr, int curIndex, int k, List<Integer> tmp){
        if (k == 0){
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = curIndex; i < arr.length - k + 1; i++) {
            tmp.add(arr[i]);
            find(arr,i+1, k-1, tmp);
            tmp.remove(tmp.size() - 1);

        }



    }

    public static void getMax(String fileName){
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(fileName));
            String tmp = null;

            int line = 1;
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
            Date startDate = null;
            boolean first = true;
            HashMap<String, Integer> map = new HashMap<>();
            while ((tmp = reader.readLine())!=null){

                String[] strs = tmp.split(" ");
                Date curDate = sdf.parse(strs[0].replace("T", " "));
                String curJieKou = strs[1];
                if (first){
                    startDate = curDate;
                    first = false;
                }
                long cha = curDate.getTime() - startDate.getTime();
                long day_cha = cha/(24*60*60*1000);
                long hour_cha = cha/(60*60*1000)-day_cha*24;
                long min = cha/(60*1000)-day_cha*24*60-hour_cha*60;

                if(min <= 5){
                    if(map.containsKey(curJieKou)){
                        Integer t = map.get(curJieKou);
                        map.put(curJieKou, ++t);
                    }else {
                        map.put(curJieKou, 1);
                    }
                }else {
                    int max = 0;
                    String maxJieKout = null;
                    for(Map.Entry<String,Integer> entry : map.entrySet()){
                        if(entry.getValue() > max){
                            max = entry.getValue();
                            maxJieKout = entry.getKey();
                        }
                    }
                    if(maxJieKout!=null){
                        System.out.println(max + " " + maxJieKout);
                    }
                    map.clear();
                    first = true;
                }

            }
            reader.close();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            if (reader != null){
                try {
                    reader.close();
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }
    }

    static class Request{
        String name;
        int count;
        public Request(String name, int count){
            this.name = name;
            this.count = count;
        }

        public int getCount() {
            return count;
        }
    }


    public static String verify(String str){
        if(str.startsWith(".")||str.startsWith(":")||str.endsWith(".")||str.endsWith(":")){
            return "Neither";
        }
        String[] arr = str.split(".");
        if (arr.length == 4){
            int tmp = -1;
            for (int i = 0; i < 4; i++) {
                tmp = Integer.parseInt(arr[i]);

                if(tmp >= 0 && tmp <= 255){
                    if(arr[i].startsWith("0")&&arr[i].length() == 1){
                        return "Neither";
                    }
                    return "IPv4";
                }else {
                    return "Neither";

                }
            }
        }else {
            arr = str.split(":");
            if (arr.length == 8){
                int tmp = -1;
                for (int i = 0; i < 8; i++) {
                    int length = arr[i].length();
                    if(arr[i] != null && length <5 && length > 0){
                        for (int j = 0; j < length; j++) {
                            char c = arr[i].charAt(j);
                            if((c>='0'&&c<='9')&&(c>='a'&&c<='f')&&(c>='A'&&c<='F')){
                                return "IPv6";
                            }else {
                                return "Neither";

                            }
                        }
                    }else {
                        return "Neither";
                    }
                }
            }else {
                return "Neither";
            }
        }
        return "Neither";

    }


    static ArrayList<String> res1 = new ArrayList<>();
    static String[] src = {"", "abc", "def", "ghi", "jkl","mno","pqrs","tuv","wxyz"};
    public static void dfs(String s, String tmp1){
        System.out.println(Arrays.toString(res.toArray()));
        if(s.length() == 0){
            res1.add(tmp1);
            return;
        }
        for (int i = 0; i < src[s.charAt(0) - '0' - 1].length(); i++) {
            dfs(s.substring(1), tmp1+src[s.charAt(0) - '0' - 1].charAt(i));
        }
    }

    public static void solution(int n, ArrayList<Integer> arr){
        Collections.sort(arr);

    }





}
