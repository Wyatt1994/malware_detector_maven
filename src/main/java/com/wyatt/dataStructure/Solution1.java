package com.wyatt.dataStructure;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.serializer.SimplePropertyPreFilter;
import com.wyatt.serialize_test.TestBean;
import com.wyatt.serialize_test.TestRef;

import java.io.ObjectOutputStream;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class Solution1{
    static ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    /**
     * 字符串匹配次数
     * 输入：3，aa,b,ac
     * bbaac
     * 输出：子串匹配的个数
     * @param args
     */
    public static void main(String[] args){
        System.out.println(sqrt(3));
        System.out.println(pow(2,-2));
        int[] num = {1,2,3};
        ArrayList<Integer> tmpList = new ArrayList<>();
        //外部需要进行排序
        Arrays.sort(num);

        //回溯法求字符串子集和随机打乱排列完整解析
        //https://blog.csdn.net/versencoder/article/details/52072350
        
        //获取非重复随机打乱排列
        //需要定义一个boolean数组，记录元素是否访问过
        doPermutationWithoutDuplicate(num,3,tmpList,new boolean[num.length]);
        //回溯法获取随机打乱排列
        //doPermutation(num,3,tmpList);

        //交换法获取随机打乱排列
        //doPermuteBySwap(num,0,3);

        //获取非重复子集，注意，在调用之前必须对res数组内部进行去重排序
        //doBackTrace(num,0,3,tmpList);
        System.out.println(res);
        System.exit(1);
        TestBean test = new TestBean("1","2",new TestRef("ref1","ref2"));
        System.out.println(JSON.toJSONString(test));
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        Set<String> set = new HashSet<>();
        String[] strs = new String[m];
        for(int i = 0; i < m; i++){
            set.add(sc.next());
        }
        String t = sc.next();

        int[] dp = new int[t.length()+1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = -1;
        }
        System.out.println(getResult(0,t,set));

    }


    public static int getResult(int startIndex,String t,Set<String> set){
        if(startIndex ==  t.length()){
            return 0;
        }
        int max = 0;
        for (String str:set) {
            String s = t.substring(startIndex);
            int pos = s.indexOf(str);
            if(pos >=0){
                max = Math.max(max,getResult(startIndex+str.length()+pos,t,set)+1);
            }else {
                continue;
            }
        }
        return max;

    }
    public static int dfs(int index,String t,Set<String> set){
        if(index == t.length()){
            return 0;
        }
        int max = dfs(index+1,t,set);
        for(int i = index; i < t.length(); i++){
            if(set.contains(t.substring(index,i-index+1))){
                max = Math.max(max,dfs(i+1,t,set)+1);
            }
        }
        return max;
    }

    /**
     * 不能包含重复子集
     * Input: [1,2,2]
     Output:
     [
     [2],
     [1],
     [1,2,2],
     [2,2],
     [1,2],
     []
     ]
     */
    public static void doBackTrace(int[] num, int start, int end, ArrayList<Integer> tmpList){
        res.add(new ArrayList<Integer>(tmpList));
        for (int i = start; i < end; i++) {
            //跳过重复元素,不包括自身，因此需要i>start
            if(i > start && num[i] == num[i-1]){
                continue;
            }
            else {
                tmpList.add(num[i]);
                //注意是i+1,不是start+1
                doBackTrace(num,i+1,end,tmpList);
                tmpList.remove(tmpList.size()-1);
            }

        }
    }





    /**
     * 无重复随机打乱顺序
     * Input: [1,1,2]
     Output:
     [
     [1,1,2],
     [1,2,1],
     [2,1,1]
     ]
     */

    public static void doPermutationWithoutDuplicate(int[] num, int end, ArrayList<Integer> tmpList, boolean[] used){
        if(tmpList.size() == end){
            res.add(new ArrayList<Integer>(tmpList));
            return;
        }
        for (int i = 0; i < end; i++) {
            //若已被使用，即num[i]已添加，或与上一个元素相等且上一个元素未被使用
            if(used[i] || i > 0 && num[i] == num[i-1] && !used[i-1]){
                continue;
            }else {
                used[i] = true;
                tmpList.add(num[i]);
                doPermutationWithoutDuplicate(num,end,tmpList,used);
                used[i] = false;
                tmpList.remove(tmpList.size()-1);
            }

        }
    }

    /**
     * 随机打乱顺序,无需num数组排序,也可以采用交换回溯法
     * Input: [1,2,3]
     Output:
     [
     [1,2,3],
     [1,3,2],
     [2,1,3],
     [2,3,1],
     [3,1,2],
     [3,2,1]
     ]
     */

    public static void doPermutation(int[] num, int end, ArrayList<Integer> tmpList){
        if(tmpList.size() == end){
            res.add(new ArrayList<Integer>(tmpList));
            return;
        }
        for (int i = 0; i < end; i++) {
            //避免重复添加元素，出现[1,1,1],即使用了某个元素，则不能再次使用
            if(tmpList.contains(num[i])){
                continue;
            }
            else {
                tmpList.add(num[i]);
                doPermutation(num,end,tmpList);
                tmpList.remove(tmpList.size()-1);
            }

        }
    }

    /**
     * 交换法随机打乱顺序
     */
    public static void doPermuteBySwap(int[] num, int start, int end){
        if(start == end){
            ArrayList<Integer> list = new ArrayList<>();
            for(Integer i : num){
                list.add(i);
            }
            res.add(list);
            return;
        }
        for(int i = start; i < end; i++){
            swap(num,start,i);
            doPermuteBySwap(num,start+1,end);
            swap(num,start,i);
        }
    }


    /**
     * 交换法随机打乱顺序,不包含重复序列，如[1,1]出现两个[1,1]
     */
    public static void doPermuteBySwapWithOutDuplicate(int[] num, int start, int end){
        if(start == end){
            ArrayList<Integer> list = new ArrayList<>();
            for(Integer i : num){
                list.add(i);
            }
            res.add(list);
            return;
        }
        for(int i = start; i < end; i++){
            //在排列的时候进行判断如果后面的元素与start相同时就不进行排序。
            //这样就可以避免对重复元素进行排序
            if(i == start || num[i]!=num[i-1]){
                swap(num,start,i);
                doPermuteBySwap(num,start+1,end);
                swap(num,start,i);
            }
        }
    }

    public static void swap(int[] num, int index1, int index2){
        int tmp = num[index1];
        num[index1] = num[index2];
        num[index2] = tmp;
    }


    public static double sqrt(int x) {
        if(x < 0){
            return -1;
        }
        if(x == 0){
            return 0;
        }
        double i = 0;
        double j = x;
        double t = 0.0000001d;
        double mid = 0.00d;
        while(i <= j){
            mid = (i+j)/2;
            if(Math.abs(mid*mid-x)<t){
                break;
            }
            if(mid*mid < x){
                i = mid;
            }else if(mid*mid > x){
                j = mid;
            }else{
                break;
            }
        }
        return mid;
    }

    public static double pow(double x, int n) {
        if(x == 0 && n == 0) return 1;
        if(x == 0) return 0;
        if(n == 0) return 1;
        if(n == 1){
            return x;
        }
        if(n < 0){
            return 1/(x*pow(x,-n-1));
        }else{
            return x*pow(x,n-1);
        }
    }
}